#/handlers/schedule_handlers.py ===
import re
from datetime import date, datetime, time, timedelta, timezone
from zoneinfo import ZoneInfo
from typing import Dict, Any, Optional, List
from collections import Counter
from html import escape
from telegram import Update
from telegram.ext import ContextTypes

from database.connection import db_connection  # для определения TZ пользователя
from database import time_repository as time_repo
from logic.duty import _local_cycle_day, _phase_kind
from logic.duty import resolve_slot_ddnn_alternating as resolve4
from logic.duty import resolve_slot_ddnn_alt_8 as resolve8

from database.absence_repository import get_absence_on_date
from datetime import date  # если ещё не импортирован
from telegram.constants import ParseMode  # для parse_mode=HTML

from handlers.absence_banner import reply_with_absence_banner

WEEKDAY_RU = ["Понедельник","Вторник","Среда","Четверг","Пятница","Суббота","Воскресенье"]

# Базовые окна смен (в TZ группы):
# 0,1 → день 08:00–20:00; 2,3 → ночь 20:00–08:00
SLOT_WINDOWS: Dict[int, tuple[str, str]] = {
    0: ("08:00", "20:00"),
    1: ("08:00", "20:00"),
    2: ("20:00", "08:00"),
    3: ("20:00", "08:00"),
}

def _weekday_ru(d: date) -> str:
    return WEEKDAY_RU[d.weekday()]

def _parse_hhmm(s: str) -> time:
    hh, mm = s.split(":")
    return time(int(hh), int(mm))

def _tz_from_offset_hours(offset_hours: int) -> timezone:
    return timezone(timedelta(hours=int(offset_hours or 0)))

def _get_group_tz(info: Dict[str, Any]) -> timezone | ZoneInfo:
    """
    Возвращает TZ группы:
    - сначала пробуем IANA из info['tz'] или info['tz_name']
    - иначе фиксированное смещение info['tz_offset_hours']
    - по умолчанию Europe/Moscow
    """
    tz_name = (info.get("tz") or info.get("tz_name") or "").strip()
    if tz_name:
        try:
            return ZoneInfo(tz_name)
        except Exception:
            pass
    return _tz_from_offset_hours(int(info.get("tz_offset_hours") or 0))

def _detect_user_tz_name(user_id: int) -> Optional[str]:
    """
    Пытаемся вытащить TZ пользователя из таблицы users:
      - колонка tz или tz_name (IANA)
      - или tz_offset_hours (целое)
    Если не нашли — вернём None (дальше возьмём Europe/Moscow).
    """
    try:
        conn = db_connection.get_connection()
        cur = conn.cursor()
        # Проверим наличие нужных колонок
        cur.execute("""
            SELECT column_name FROM information_schema.columns
            WHERE table_schema='public' AND table_name='users'
        """)
        cols = {r[0] for r in cur.fetchall()}

        if 'tz' in cols or 'tz_name' in cols:
            col = 'tz' if 'tz' in cols else 'tz_name'
            cur.execute(f"SELECT {col} FROM users WHERE user_id = %s LIMIT 1", (user_id,))
            row = cur.fetchone()
            cur.close()
            if row and row[0]:
                return str(row[0]).strip()

        if 'tz_offset_hours' in cols:
            cur.execute("SELECT tz_offset_hours FROM users WHERE user_id = %s LIMIT 1", (user_id,))
            row = cur.fetchone()
            cur.close()
            if row is not None and row[0] is not None:
                # для фиксированного смещения вернём псевдо-строку
                return f"FIXED:{int(row[0])}"
        cur.close()
    except Exception:
        # не падаем — просто вернём None
        pass
    return None

def _get_user_tz(update: Update) -> timezone | ZoneInfo:
    """
    Итоговый TZ пользователя:
    - users.tz/users.tz_name → ZoneInfo(...)
    - FIXED:<h> → timezone(hours=h)
    - иначе Europe/Moscow
    """
    uid = update.effective_user.id
    tz_name = _detect_user_tz_name(uid)
    if tz_name:
        if tz_name.startswith("FIXED:"):
            try:
                off = int(tz_name.split(":", 1)[1])
                return _tz_from_offset_hours(off)
            except Exception:
                pass
        try:
            return ZoneInfo(tz_name)
        except Exception:
            pass
    # дефолт
    return ZoneInfo("Europe/Moscow")

def _convert_range_for_user(on_date: date,
                            start_hhmm: str,
                            end_hhmm: str,
                            tz_from,
                            tz_to) -> tuple[str, str]:
    """
    Конвертирует интервал start–end на конкретную дату из tz_from в tz_to.
    Учитывает «перевал через полночь».
    Возвращает HH:MM, HH:MM (строки в локали пользователя).
    """
    s_t = _parse_hhmm(start_hhmm)
    e_t = _parse_hhmm(end_hhmm)

    start_dt = datetime.combine(on_date, s_t, tzinfo=tz_from)
    end_dt = datetime.combine(on_date, e_t, tzinfo=tz_from)
    if end_dt <= start_dt:
        end_dt += timedelta(days=1)

    start_user = start_dt.astimezone(tz_to)
    end_user = end_dt.astimezone(tz_to)

    return start_user.strftime("%H:%M"), end_user.strftime("%H:%M")

def _phase_kind_for_group(info: Dict[str, Any], on_date: date) -> str:
    idx = _local_cycle_day({
        "epoch": info.get("epoch"),
        "offset_days": 0,
        "tz_offset_hours": int(info.get("tz_offset_hours") or 0),
        "period": int(info.get("period") or info.get("rotation_period_days") or 4),
    }, on_date)
    return _phase_kind(idx)  # 'day'|'night'|'off'

def _slot_idx_for_member(info: Dict[str, Any], on_date: date, base_pos: int) -> Optional[int]:
    epoch = info.get("epoch")
    period = int(info.get("period") or info.get("rotation_period_days") or 4)
    if period == 8:
        return resolve8(epoch, 8, base_pos, on_date)
    return resolve4(epoch, 4, base_pos, on_date)

def _choose_group_window(info: Dict[str, Any], on_date: date, used_slots: List[int]) -> tuple[str, str]:
    """
    Выбираем базовое окно смены (в TZ группы) для заголовка:
    - если у участников есть слоты → берем самый частый слот и его окно;
    - иначе → от фазы day/night выбираем 08–20 или 20–08.
    """
    if used_slots:
        pos, _ = Counter(used_slots).most_common(1)[0]
        if pos in SLOT_WINDOWS:
            return SLOT_WINDOWS[pos]

    # fallback по фазе
    kind = _phase_kind_for_group(info, on_date)
    if kind == "night":
        return ("20:00", "08:00")
    else:
        return ("08:00", "20:00")

def _group_display_name(info: Dict[str, Any]) -> str:
    name = (info.get("name") or "").strip()
    return name or str(info.get("key") or "Группа")

def _member_line(m: Dict[str, Any], label: str) -> str:
    fn = (m.get("first_name") or "").strip()
    ln = (m.get("last_name") or "").strip()
    un = (m.get("username") or "").strip()
    display = (f"{fn} {ln}".strip() or (f"@{un}" if un else str(m.get("user_id"))))
    if un and f"@{un}" not in display:
        display += f" @{un}"
    return f'• {display} — "{label}"'

def _member_display(m: Dict[str, Any]) -> str:
    fn = (m.get("first_name") or "").strip()
    ln = (m.get("last_name") or "").strip()
    un = (m.get("username") or "").strip()
    label = (f"{escape(fn)} {escape(ln)}").strip() or (f"@{escape(un)}" if un else str(m.get("user_id")))
    if un and f"@{un}" not in label:
        label += f" @{escape(un)}"
    return label

def _slot_line(slot: Dict[str, Any]) -> str:
    # slot: {"pos": int, "start": "HH:MM", "end": "HH:MM", "name": "..."}
    nm = escape(slot.get("name") or "")
    return f"{slot['start']}–{slot['end']} {nm} (слот {slot['pos']})"

def _resolve_slot_for_member(info: Dict[str, Any], on_date: date, base_pos: int) -> Optional[int]:
    """Вернёт индекс слота (int) или None (если отдых в period=8)."""
    epoch = info.get("epoch")                      # date
    period = int(info.get("period") or info.get("rotation_period_days") or 4)
    if period == 8:
        return resolve8(epoch, 8, base_pos, on_date)
    # по умолчанию считаем 4 (ДД/НН без OFF)
    return resolve4(epoch, 4, base_pos, on_date)

def _assignments_for_date(on_date: date) -> List[str]:
    """Собирает краткое расписание всех групп на заданную дату."""
    lines: List[str] = []
    groups = time_repo.list_groups()  # [{'key', 'profile_key', ...}]
    if not groups:
        return lines

    # идём по группам и детализируем через get_group_info
    for g in groups:
        info = time_repo.get_group_info(g["key"])
        if not info:
            continue

        # вычислим фазу дня (дневная/ночная), чтобы не шуметь "выходным" при period=4
        # при period=8 "off" тоже возможен — тогда пропустим группу (в ней никто не работает)
        idx = _local_cycle_day({
            "epoch": info.get("epoch"),
            "offset_days": 0,
            "tz_offset_hours": int(info.get("tz_offset_hours") or 0),
            "period": int(info.get("period") or info.get("rotation_period_days") or 4),
        }, on_date)
        kind = _phase_kind(idx)  # "day" | "night" | "off"

        slots = info.get("slots", [])
        members = info.get("members", [])
        day_lines: List[str] = []

        for m in members:
            base_pos = int(m.get("base_pos") or 0)
            slot_idx = _resolve_slot_for_member(info, on_date, base_pos)
            if slot_idx is None:
                # отдых (period=8, фаза OFF) — у пользователя нет смены
                continue
            slot = next((s for s in slots if s["pos"] == slot_idx), None)
            if not slot:
                continue
            day_lines.append(f"• <b>{_member_display(m)}</b> — {_slot_line(slot)}")

        if day_lines:
            lines.append(
                f"👷 <b>{escape(info['key'])}</b> (профиль <code>{escape(info['profile_key'])}</code>, {escape(kind)})"
            )
            lines.extend(day_lines)
            lines.append("")

    return lines

def _my_assignments_for_date(uid: int, on_date: date) -> List[str]:
    """Возвращает строки только по заданному пользователю."""
    lines: List[str] = []
    groups = time_repo.list_groups()
    for g in groups:
        info = time_repo.get_group_info(g["key"])
        if not info:
            continue

        me = next((m for m in info.get("members", []) if int(m.get("user_id")) == int(uid)), None)
        if not me:
            continue

        # вычисляем слот
        slot_idx = _resolve_slot_for_member(info, on_date, int(me.get("base_pos") or 0))
        if slot_idx is None:
            # отдых — покажем явно
            lines.append(
                f"• <b>{escape(info['key'])}</b> — выходной (отдых)"
            )
            continue

        slots = info.get("slots", [])
        slot = next((s for s in slots if s["pos"] == slot_idx), None)
        if slot:
            lines.append(
                f"• <b>{escape(info['key'])}</b> — {_slot_line(slot)}"
            )
        else:
            lines.append(
                f"• <b>{escape(info['key'])}</b> — слот {slot_idx}"
            )
    return lines

def _ru_weekday(d: date) -> str:
    names = ["Понедельник","Вторник","Среда","Четверг","Пятница","Суббота","Воскресенье"]
    return names[d.weekday()]

def _my_assignments_compact(uid: int, on_date: date) -> list[str]:
    """
    Вернёт список коротких строк для конкретного пользователя на заданную дату:
    формат: HH:MM–HH:MM "Название"
    Группы не упоминаем, только сами слоты. Если ничего — вернём [].
    """
    results: list[str] = []
    for g in (time_repo.list_groups() or []):
        info = time_repo.get_group_info(g["key"])
        if not info:
            continue

        me = next((m for m in info.get("members", []) if int(m.get("user_id")) == int(uid)), None)
        if not me:
            continue

        epoch = info.get("epoch")                       # date
        period = int(info.get("period") or info.get("rotation_period_days") or 4)
        base_pos = int(me.get("base_pos") or 0)

        # выберем нужный резолвер
        if period == 8 and resolve8 is not None:
            slot_idx = resolve8(epoch, period, base_pos, on_date)
        else:
            slot_idx = resolve4(epoch, 4, base_pos, on_date)

        if slot_idx is None:
            # день отдыха в 8-дневной схеме — просто не добавляем строку (пусть выйдет "Выходной")
            continue

        slot = next((s for s in info.get("slots", []) if s["pos"] == slot_idx), None)
        if not slot:
            continue

        start = slot["start"]
        end = slot["end"]
        name = (slot.get("name") or "").strip()
        if name:
            results.append(f'{start}–{end} "{escape(name)}"')
        else:
            results.append(f"{start}–{end}")

    return results

async def my_next_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id

    # ваша текущая логика поиска следующей смены:
    # next_shift = find_next_shift_for_user(user_id)  # пример

                 + "\n⚠️ <b>День попадает в отсутствие</b>\n"

    # ваш существующий текст:

    user_id = update.effective_user.id
    await reply_with_absence_banner(update, text_html, user_id)

async def next_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
                 + "\n⚠️ <b>День попадает в отсутствие</b>\n"

    user_id = update.effective_user.id
    await reply_with_absence_banner(update, text_html, user_id)
##############################################33
#Старое №№№№№№№№№№№
#########33#################333333

async def today_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    on_date = date.today()
    msg = build_duty_message(on_date, uid)
    await update.message.reply_text(msg, parse_mode="HTML")

async def tomorrow_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    on_date = date.today() + timedelta(days=1)
    msg = build_duty_message(on_date, uid)
    await update.message.reply_text(msg, parse_mode="HTML")

async def ondate_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    /ondate 05.09.2025   или   /ondate 5.09   (год подставится текущий)
    """
    uid = update.effective_user.id
    if not context.args:
        await update.message.reply_text("Укажи дату: /ondate DD.MM или /ondate DD.MM.YYYY")
        return
    raw = " ".join(context.args)
    on_date = parse_date_arg(raw)
    if not on_date:
        await update.message.reply_text("Не понял дату. Пример: /ondate 05.09.2025")
        return
    msg = build_duty_message(on_date, uid)
    await update.message.reply_text(msg, parse_mode="HTML")
